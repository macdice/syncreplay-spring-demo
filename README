This is a test Java/Spring application for experimenting with the proposed
PostgreSQL feature "synchronous replay".  It is intended to show that typical
modern application stacks could make practical use of the semantics provided
by that feature.

The application is a simple RESTful key/value store, which can be accessed
like so:

 $ curl -X PUT -H "Content-Type: text/plain" -d 'b' localhost:9000/key-value/a
 {"key":"a","value":"b"}
 $ curl localhost:9000/key-value/a
 {"key":"a","value":"b"}

GET requests are sent to randomly chosen read-only replica database servers
and PUT requests should go to the primary database server.  GET requests
should see the most recently PUT value for any key at all times (no
replication lag), and failing replica database servers should have a limited
impact on the primary server and application.

The application code is in KeyValueController.java and contains no special
handling for retrying or rerouting, except for the standard Spring annotations
for declarative transactions such as @Transactional(readOnly=true).  These
annotations are already be used by other libraries such as MySQL Connector/J
for a similar purpose.  The code to add routing and retries consists of a
custom DataSource implementation that in turn manages a set of real DataSource
objects (the pools of connections to each database server), and some AOP
advice that can be defined globally for your application to enable retries and
and readonlyrouting.

This requires a set of PostgreSQL servers running the latest master code
patched with this:

 https://www.postgresql.org/message-id/CAEepm%3D0YigNQczAF-%3Dx_SxT6cJv77Yb0EO%2BcAFnqRyVu4%2BbKFw%40mail.gmail.com

The script accompanying the above patch may be useful to start replica
servers.  A table must be created first:

 CREATE TABLE key_value (key text PRIMARY KEY, value text NOT NULL);

This is work in progress, pull requests welcome!
